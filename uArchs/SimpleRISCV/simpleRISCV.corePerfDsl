/*********************************** Microaction Section ***********************************/
Connector {Pc, Pc_p, Pc_np}
Connector {Xa, Xb, Xd}

Resource {PC_Gen, Decoder, ALU, Multi, Reg, DPort_W(dMemModel), DPort_R(dMemModel), IPort_R(iMemModel)}
virtual Resource v_IPort

// General Microactions
Microaction {
    uA_IF (Pc -> v_IPort),
    uA_PC_GEN (Pc -> PC_Gen -> Pc_p),
    uA_ID (Decoder),
    uA_OF_A (Xa),
    uA_OF_B (Xb),
    uA_ALU_branch (ALU -> Pc_np),
    uA_ALU_mem (ALU),
    uA_MEM_W (DPort_W)
}

// Non-forwarding Microactions
Microaction {
    uA_ALU_arith_nfw (ALU),
    uA_MUL_nfw (Multi),
    uA_MEM_R_nfw (DPort_R),
    uA_WB_nfw (Reg -> Xd)
}

// Forwarding Microactions
Microaction {
    uA_ALU_arith_fw (ALU -> Xd),
    uA_MUL_fw (Multi -> Xd),
    uA_MEM_R_fw (DPort_R -> Xd),
    uA_WB_fw (Reg)
}

// Virtual Microactions
virtual Microaction {
    vuA_ALU_arith,
    vuA_MUL,
    vuA_MEM_R,
    vuA_WB
}

/*********************************** Stages & Pipeline ***********************************/
Stage {
    IF_stage (uA_IF, uA_PC_GEN),
    ID_stage (uA_ID, uA_OF_A, uA_OF_B),
    EX_stage (vuA_ALU_arith, vuA_MUL, uA_ALU_branch, uA_ALU_mem),
    MEM_stage (vuA_MEM_R, uA_MEM_W),
    WB_stage (vuA_WB)
}
Pipeline SimplePipeline (IF_stage -> ID_stage -> EX_stage -> MEM_stage -> WB_stage)

/*********************************** External Models ***********************************/
TraceValue {rs1, rs2, rd, pc, brTarget}

ConnectorModel regModel (
    link : StandardRegisterModel
    trace : {rs1, rs2, rd}
    connectorIn : Xd
    connectorOut : {Xa, Xb}
)

ConnectorModel dynBranchPredModel (
    link : DynamicBranchPredictModel
    trace : {pc, brTarget}
    connectorIn : {Pc_p, Pc_np}
    connectorOut : Pc
)

ConnectorModel staBranchPredModel (
    link : StaticBranchPredictModel
    trace : {pc, brTarget}
    connectorIn : {Pc_p, Pc_np}
    connectorOut : Pc
)

ConnectorModel noBranchPredModel (
    link : NoBranchPredictModel
    trace : {pc, brTarget}
    connectorIn : {Pc_p, Pc_np}
    connectorOut : Pc
)

ResourceModel iMemModel (
    link : DummyMemoryModel
)

ResourceModel dMemModel (
    link : DummyMemoryModel
)

/*********************************** Instruction Section ***********************************/
InstrGroup {
    Arith_Ra_Rb (add, sub, sll, xor, or, and, c_add),
    Mul (mul, rem),
    Arith_Ra (addi, sltiu, xori, ori, andi, c_addi, c_slli, c_addi16sp),
    Arith_Rb (c_mv),
    Arith_X (c_li),
    Store (sb, sh, sw, c_sw),
    Load (lh, lw, lbu, lhu, c_lw),
    Branch_Ra_Rb (beq, bne, blt, bge, bltu, bgeu),
    Branch_Ra (c_beqz, c_bnez),
    Default ([?])
}

MicroactionMapping {
    [ALL] : {uA_IF, uA_PC_GEN, uA_ID},
    //Default : {},
    Arith_Ra_Rb : {uA_OF_A, uA_OF_B, vuA_ALU_arith, vuA_WB},
    Arith_Ra : {uA_OF_A, vuA_ALU_arith, vuA_WB},
    Arith_Rb : {uA_OF_B, vuA_ALU_arith, vuA_WB},
    Arith_X :  {vuA_ALU_arith, vuA_WB},
    Mul : {uA_OF_A, uA_OF_B, vuA_MUL, vuA_WB},
    Store : {uA_OF_A, uA_OF_B, uA_ALU_mem, uA_MEM_W},
    Load : {uA_OF_A, uA_ALU_mem, vuA_MEM_R, vuA_WB},
    Branch_Ra_Rb : {uA_OF_A, uA_OF_B, uA_ALU_branch},
    Branch_Ra : {uA_OF_A, uA_ALU_branch}
}

TraceValueMapping {
    [ALL] : {
        rs1 = "XXX",
        rs2 = "XXX",
        rd = "XXX",
        pc = "XXX",
        brTarget = "XXX"
    }
}

/*********************************** Variants ***********************************/

CorePerfModel SimpleRISCV_H_fw_DynBrPred (
    use Pipeline : SimplePipeline
    use ConnectorModel : {dynBranchPredModel, regModel}
    assign Resource : v_IPort = IPort_R
    assign Microaction : {
        vuA_ALU_arith = uA_ALU_arith_fw,
        vuA_MUL = uA_MUL_fw,
        vuA_MEM_R = uA_MEM_R_fw,
        vuA_WB = uA_WB_fw
    }
)